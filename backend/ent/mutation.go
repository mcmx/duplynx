// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/mcmx/duplynx/ent/actionaudit"
	"github.com/mcmx/duplynx/ent/duplicategroup"
	"github.com/mcmx/duplynx/ent/fileinstance"
	"github.com/mcmx/duplynx/ent/machine"
	"github.com/mcmx/duplynx/ent/predicate"
	"github.com/mcmx/duplynx/ent/scan"
	"github.com/mcmx/duplynx/ent/tenant"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActionAudit    = "ActionAudit"
	TypeDuplicateGroup = "DuplicateGroup"
	TypeFileInstance   = "FileInstance"
	TypeMachine        = "Machine"
	TypeScan           = "Scan"
	TypeTenant         = "Tenant"
)

// ActionAuditMutation represents an operation that mutates the ActionAudit nodes in the graph.
type ActionAuditMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	actor                  *string
	action_type            *actionaudit.ActionType
	payload                *map[string]interface{}
	performed_at           *time.Time
	stubbed                *bool
	clearedFields          map[string]struct{}
	tenant                 *uuid.UUID
	clearedtenant          bool
	duplicate_group        *uuid.UUID
	clearedduplicate_group bool
	done                   bool
	oldValue               func(context.Context) (*ActionAudit, error)
	predicates             []predicate.ActionAudit
}

var _ ent.Mutation = (*ActionAuditMutation)(nil)

// actionauditOption allows management of the mutation configuration using functional options.
type actionauditOption func(*ActionAuditMutation)

// newActionAuditMutation creates new mutation for the ActionAudit entity.
func newActionAuditMutation(c config, op Op, opts ...actionauditOption) *ActionAuditMutation {
	m := &ActionAuditMutation{
		config:        c,
		op:            op,
		typ:           TypeActionAudit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionAuditID sets the ID field of the mutation.
func withActionAuditID(id uuid.UUID) actionauditOption {
	return func(m *ActionAuditMutation) {
		var (
			err   error
			once  sync.Once
			value *ActionAudit
		)
		m.oldValue = func(ctx context.Context) (*ActionAudit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ActionAudit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActionAudit sets the old ActionAudit of the mutation.
func withActionAudit(node *ActionAudit) actionauditOption {
	return func(m *ActionAuditMutation) {
		m.oldValue = func(context.Context) (*ActionAudit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionAuditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionAuditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ActionAudit entities.
func (m *ActionAuditMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionAuditMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionAuditMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ActionAudit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ActionAuditMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ActionAuditMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ActionAuditMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ActionAuditMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ActionAuditMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ActionAuditMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ActionAuditMutation) SetTenantID(u uuid.UUID) {
	m.tenant = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ActionAuditMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ActionAuditMutation) ResetTenantID() {
	m.tenant = nil
}

// SetDuplicateGroupID sets the "duplicate_group_id" field.
func (m *ActionAuditMutation) SetDuplicateGroupID(u uuid.UUID) {
	m.duplicate_group = &u
}

// DuplicateGroupID returns the value of the "duplicate_group_id" field in the mutation.
func (m *ActionAuditMutation) DuplicateGroupID() (r uuid.UUID, exists bool) {
	v := m.duplicate_group
	if v == nil {
		return
	}
	return *v, true
}

// OldDuplicateGroupID returns the old "duplicate_group_id" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldDuplicateGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuplicateGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuplicateGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuplicateGroupID: %w", err)
	}
	return oldValue.DuplicateGroupID, nil
}

// ResetDuplicateGroupID resets all changes to the "duplicate_group_id" field.
func (m *ActionAuditMutation) ResetDuplicateGroupID() {
	m.duplicate_group = nil
}

// SetActor sets the "actor" field.
func (m *ActionAuditMutation) SetActor(s string) {
	m.actor = &s
}

// Actor returns the value of the "actor" field in the mutation.
func (m *ActionAuditMutation) Actor() (r string, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActor returns the old "actor" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldActor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor: %w", err)
	}
	return oldValue.Actor, nil
}

// ResetActor resets all changes to the "actor" field.
func (m *ActionAuditMutation) ResetActor() {
	m.actor = nil
}

// SetActionType sets the "action_type" field.
func (m *ActionAuditMutation) SetActionType(at actionaudit.ActionType) {
	m.action_type = &at
}

// ActionType returns the value of the "action_type" field in the mutation.
func (m *ActionAuditMutation) ActionType() (r actionaudit.ActionType, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "action_type" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldActionType(ctx context.Context) (v actionaudit.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ResetActionType resets all changes to the "action_type" field.
func (m *ActionAuditMutation) ResetActionType() {
	m.action_type = nil
}

// SetPayload sets the "payload" field.
func (m *ActionAuditMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *ActionAuditMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *ActionAuditMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[actionaudit.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *ActionAuditMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[actionaudit.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *ActionAuditMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, actionaudit.FieldPayload)
}

// SetPerformedAt sets the "performed_at" field.
func (m *ActionAuditMutation) SetPerformedAt(t time.Time) {
	m.performed_at = &t
}

// PerformedAt returns the value of the "performed_at" field in the mutation.
func (m *ActionAuditMutation) PerformedAt() (r time.Time, exists bool) {
	v := m.performed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformedAt returns the old "performed_at" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldPerformedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformedAt: %w", err)
	}
	return oldValue.PerformedAt, nil
}

// ResetPerformedAt resets all changes to the "performed_at" field.
func (m *ActionAuditMutation) ResetPerformedAt() {
	m.performed_at = nil
}

// SetStubbed sets the "stubbed" field.
func (m *ActionAuditMutation) SetStubbed(b bool) {
	m.stubbed = &b
}

// Stubbed returns the value of the "stubbed" field in the mutation.
func (m *ActionAuditMutation) Stubbed() (r bool, exists bool) {
	v := m.stubbed
	if v == nil {
		return
	}
	return *v, true
}

// OldStubbed returns the old "stubbed" field's value of the ActionAudit entity.
// If the ActionAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionAuditMutation) OldStubbed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStubbed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStubbed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStubbed: %w", err)
	}
	return oldValue.Stubbed, nil
}

// ResetStubbed resets all changes to the "stubbed" field.
func (m *ActionAuditMutation) ResetStubbed() {
	m.stubbed = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ActionAuditMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[actionaudit.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ActionAuditMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ActionAuditMutation) TenantIDs() (ids []uuid.UUID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ActionAuditMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearDuplicateGroup clears the "duplicate_group" edge to the DuplicateGroup entity.
func (m *ActionAuditMutation) ClearDuplicateGroup() {
	m.clearedduplicate_group = true
	m.clearedFields[actionaudit.FieldDuplicateGroupID] = struct{}{}
}

// DuplicateGroupCleared reports if the "duplicate_group" edge to the DuplicateGroup entity was cleared.
func (m *ActionAuditMutation) DuplicateGroupCleared() bool {
	return m.clearedduplicate_group
}

// DuplicateGroupIDs returns the "duplicate_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DuplicateGroupID instead. It exists only for internal usage by the builders.
func (m *ActionAuditMutation) DuplicateGroupIDs() (ids []uuid.UUID) {
	if id := m.duplicate_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDuplicateGroup resets all changes to the "duplicate_group" edge.
func (m *ActionAuditMutation) ResetDuplicateGroup() {
	m.duplicate_group = nil
	m.clearedduplicate_group = false
}

// Where appends a list predicates to the ActionAuditMutation builder.
func (m *ActionAuditMutation) Where(ps ...predicate.ActionAudit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionAuditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionAuditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ActionAudit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionAuditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionAuditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ActionAudit).
func (m *ActionAuditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionAuditMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, actionaudit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, actionaudit.FieldUpdateTime)
	}
	if m.tenant != nil {
		fields = append(fields, actionaudit.FieldTenantID)
	}
	if m.duplicate_group != nil {
		fields = append(fields, actionaudit.FieldDuplicateGroupID)
	}
	if m.actor != nil {
		fields = append(fields, actionaudit.FieldActor)
	}
	if m.action_type != nil {
		fields = append(fields, actionaudit.FieldActionType)
	}
	if m.payload != nil {
		fields = append(fields, actionaudit.FieldPayload)
	}
	if m.performed_at != nil {
		fields = append(fields, actionaudit.FieldPerformedAt)
	}
	if m.stubbed != nil {
		fields = append(fields, actionaudit.FieldStubbed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionAuditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case actionaudit.FieldCreateTime:
		return m.CreateTime()
	case actionaudit.FieldUpdateTime:
		return m.UpdateTime()
	case actionaudit.FieldTenantID:
		return m.TenantID()
	case actionaudit.FieldDuplicateGroupID:
		return m.DuplicateGroupID()
	case actionaudit.FieldActor:
		return m.Actor()
	case actionaudit.FieldActionType:
		return m.ActionType()
	case actionaudit.FieldPayload:
		return m.Payload()
	case actionaudit.FieldPerformedAt:
		return m.PerformedAt()
	case actionaudit.FieldStubbed:
		return m.Stubbed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionAuditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case actionaudit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case actionaudit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case actionaudit.FieldTenantID:
		return m.OldTenantID(ctx)
	case actionaudit.FieldDuplicateGroupID:
		return m.OldDuplicateGroupID(ctx)
	case actionaudit.FieldActor:
		return m.OldActor(ctx)
	case actionaudit.FieldActionType:
		return m.OldActionType(ctx)
	case actionaudit.FieldPayload:
		return m.OldPayload(ctx)
	case actionaudit.FieldPerformedAt:
		return m.OldPerformedAt(ctx)
	case actionaudit.FieldStubbed:
		return m.OldStubbed(ctx)
	}
	return nil, fmt.Errorf("unknown ActionAudit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionAuditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case actionaudit.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case actionaudit.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case actionaudit.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case actionaudit.FieldDuplicateGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuplicateGroupID(v)
		return nil
	case actionaudit.FieldActor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor(v)
		return nil
	case actionaudit.FieldActionType:
		v, ok := value.(actionaudit.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case actionaudit.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case actionaudit.FieldPerformedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformedAt(v)
		return nil
	case actionaudit.FieldStubbed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStubbed(v)
		return nil
	}
	return fmt.Errorf("unknown ActionAudit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionAuditMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionAuditMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionAuditMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ActionAudit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionAuditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(actionaudit.FieldPayload) {
		fields = append(fields, actionaudit.FieldPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionAuditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionAuditMutation) ClearField(name string) error {
	switch name {
	case actionaudit.FieldPayload:
		m.ClearPayload()
		return nil
	}
	return fmt.Errorf("unknown ActionAudit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionAuditMutation) ResetField(name string) error {
	switch name {
	case actionaudit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case actionaudit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case actionaudit.FieldTenantID:
		m.ResetTenantID()
		return nil
	case actionaudit.FieldDuplicateGroupID:
		m.ResetDuplicateGroupID()
		return nil
	case actionaudit.FieldActor:
		m.ResetActor()
		return nil
	case actionaudit.FieldActionType:
		m.ResetActionType()
		return nil
	case actionaudit.FieldPayload:
		m.ResetPayload()
		return nil
	case actionaudit.FieldPerformedAt:
		m.ResetPerformedAt()
		return nil
	case actionaudit.FieldStubbed:
		m.ResetStubbed()
		return nil
	}
	return fmt.Errorf("unknown ActionAudit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionAuditMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, actionaudit.EdgeTenant)
	}
	if m.duplicate_group != nil {
		edges = append(edges, actionaudit.EdgeDuplicateGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionAuditMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case actionaudit.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case actionaudit.EdgeDuplicateGroup:
		if id := m.duplicate_group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionAuditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionAuditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionAuditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, actionaudit.EdgeTenant)
	}
	if m.clearedduplicate_group {
		edges = append(edges, actionaudit.EdgeDuplicateGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionAuditMutation) EdgeCleared(name string) bool {
	switch name {
	case actionaudit.EdgeTenant:
		return m.clearedtenant
	case actionaudit.EdgeDuplicateGroup:
		return m.clearedduplicate_group
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionAuditMutation) ClearEdge(name string) error {
	switch name {
	case actionaudit.EdgeTenant:
		m.ClearTenant()
		return nil
	case actionaudit.EdgeDuplicateGroup:
		m.ClearDuplicateGroup()
		return nil
	}
	return fmt.Errorf("unknown ActionAudit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionAuditMutation) ResetEdge(name string) error {
	switch name {
	case actionaudit.EdgeTenant:
		m.ResetTenant()
		return nil
	case actionaudit.EdgeDuplicateGroup:
		m.ResetDuplicateGroup()
		return nil
	}
	return fmt.Errorf("unknown ActionAudit edge %s", name)
}

// DuplicateGroupMutation represents an operation that mutates the DuplicateGroup nodes in the graph.
type DuplicateGroupMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	hash                  *string
	status                *duplicategroup.Status
	file_count            *int
	addfile_count         *int
	total_size_bytes      *int64
	addtotal_size_bytes   *int64
	clearedFields         map[string]struct{}
	tenant                *uuid.UUID
	clearedtenant         bool
	scan                  *uuid.UUID
	clearedscan           bool
	keeper_machine        *uuid.UUID
	clearedkeeper_machine bool
	file_instances        map[uuid.UUID]struct{}
	removedfile_instances map[uuid.UUID]struct{}
	clearedfile_instances bool
	action_audits         map[uuid.UUID]struct{}
	removedaction_audits  map[uuid.UUID]struct{}
	clearedaction_audits  bool
	done                  bool
	oldValue              func(context.Context) (*DuplicateGroup, error)
	predicates            []predicate.DuplicateGroup
}

var _ ent.Mutation = (*DuplicateGroupMutation)(nil)

// duplicategroupOption allows management of the mutation configuration using functional options.
type duplicategroupOption func(*DuplicateGroupMutation)

// newDuplicateGroupMutation creates new mutation for the DuplicateGroup entity.
func newDuplicateGroupMutation(c config, op Op, opts ...duplicategroupOption) *DuplicateGroupMutation {
	m := &DuplicateGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeDuplicateGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDuplicateGroupID sets the ID field of the mutation.
func withDuplicateGroupID(id uuid.UUID) duplicategroupOption {
	return func(m *DuplicateGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *DuplicateGroup
		)
		m.oldValue = func(ctx context.Context) (*DuplicateGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DuplicateGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDuplicateGroup sets the old DuplicateGroup of the mutation.
func withDuplicateGroup(node *DuplicateGroup) duplicategroupOption {
	return func(m *DuplicateGroupMutation) {
		m.oldValue = func(context.Context) (*DuplicateGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DuplicateGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DuplicateGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DuplicateGroup entities.
func (m *DuplicateGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DuplicateGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DuplicateGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DuplicateGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DuplicateGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DuplicateGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DuplicateGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DuplicateGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DuplicateGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DuplicateGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *DuplicateGroupMutation) SetTenantID(u uuid.UUID) {
	m.tenant = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DuplicateGroupMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DuplicateGroupMutation) ResetTenantID() {
	m.tenant = nil
}

// SetScanID sets the "scan_id" field.
func (m *DuplicateGroupMutation) SetScanID(u uuid.UUID) {
	m.scan = &u
}

// ScanID returns the value of the "scan_id" field in the mutation.
func (m *DuplicateGroupMutation) ScanID() (r uuid.UUID, exists bool) {
	v := m.scan
	if v == nil {
		return
	}
	return *v, true
}

// OldScanID returns the old "scan_id" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldScanID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanID: %w", err)
	}
	return oldValue.ScanID, nil
}

// ResetScanID resets all changes to the "scan_id" field.
func (m *DuplicateGroupMutation) ResetScanID() {
	m.scan = nil
}

// SetKeeperMachineID sets the "keeper_machine_id" field.
func (m *DuplicateGroupMutation) SetKeeperMachineID(u uuid.UUID) {
	m.keeper_machine = &u
}

// KeeperMachineID returns the value of the "keeper_machine_id" field in the mutation.
func (m *DuplicateGroupMutation) KeeperMachineID() (r uuid.UUID, exists bool) {
	v := m.keeper_machine
	if v == nil {
		return
	}
	return *v, true
}

// OldKeeperMachineID returns the old "keeper_machine_id" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldKeeperMachineID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeeperMachineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeeperMachineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeeperMachineID: %w", err)
	}
	return oldValue.KeeperMachineID, nil
}

// ClearKeeperMachineID clears the value of the "keeper_machine_id" field.
func (m *DuplicateGroupMutation) ClearKeeperMachineID() {
	m.keeper_machine = nil
	m.clearedFields[duplicategroup.FieldKeeperMachineID] = struct{}{}
}

// KeeperMachineIDCleared returns if the "keeper_machine_id" field was cleared in this mutation.
func (m *DuplicateGroupMutation) KeeperMachineIDCleared() bool {
	_, ok := m.clearedFields[duplicategroup.FieldKeeperMachineID]
	return ok
}

// ResetKeeperMachineID resets all changes to the "keeper_machine_id" field.
func (m *DuplicateGroupMutation) ResetKeeperMachineID() {
	m.keeper_machine = nil
	delete(m.clearedFields, duplicategroup.FieldKeeperMachineID)
}

// SetHash sets the "hash" field.
func (m *DuplicateGroupMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *DuplicateGroupMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *DuplicateGroupMutation) ResetHash() {
	m.hash = nil
}

// SetStatus sets the "status" field.
func (m *DuplicateGroupMutation) SetStatus(d duplicategroup.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DuplicateGroupMutation) Status() (r duplicategroup.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldStatus(ctx context.Context) (v duplicategroup.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DuplicateGroupMutation) ResetStatus() {
	m.status = nil
}

// SetFileCount sets the "file_count" field.
func (m *DuplicateGroupMutation) SetFileCount(i int) {
	m.file_count = &i
	m.addfile_count = nil
}

// FileCount returns the value of the "file_count" field in the mutation.
func (m *DuplicateGroupMutation) FileCount() (r int, exists bool) {
	v := m.file_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFileCount returns the old "file_count" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldFileCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileCount: %w", err)
	}
	return oldValue.FileCount, nil
}

// AddFileCount adds i to the "file_count" field.
func (m *DuplicateGroupMutation) AddFileCount(i int) {
	if m.addfile_count != nil {
		*m.addfile_count += i
	} else {
		m.addfile_count = &i
	}
}

// AddedFileCount returns the value that was added to the "file_count" field in this mutation.
func (m *DuplicateGroupMutation) AddedFileCount() (r int, exists bool) {
	v := m.addfile_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileCount resets all changes to the "file_count" field.
func (m *DuplicateGroupMutation) ResetFileCount() {
	m.file_count = nil
	m.addfile_count = nil
}

// SetTotalSizeBytes sets the "total_size_bytes" field.
func (m *DuplicateGroupMutation) SetTotalSizeBytes(i int64) {
	m.total_size_bytes = &i
	m.addtotal_size_bytes = nil
}

// TotalSizeBytes returns the value of the "total_size_bytes" field in the mutation.
func (m *DuplicateGroupMutation) TotalSizeBytes() (r int64, exists bool) {
	v := m.total_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSizeBytes returns the old "total_size_bytes" field's value of the DuplicateGroup entity.
// If the DuplicateGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DuplicateGroupMutation) OldTotalSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSizeBytes: %w", err)
	}
	return oldValue.TotalSizeBytes, nil
}

// AddTotalSizeBytes adds i to the "total_size_bytes" field.
func (m *DuplicateGroupMutation) AddTotalSizeBytes(i int64) {
	if m.addtotal_size_bytes != nil {
		*m.addtotal_size_bytes += i
	} else {
		m.addtotal_size_bytes = &i
	}
}

// AddedTotalSizeBytes returns the value that was added to the "total_size_bytes" field in this mutation.
func (m *DuplicateGroupMutation) AddedTotalSizeBytes() (r int64, exists bool) {
	v := m.addtotal_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSizeBytes resets all changes to the "total_size_bytes" field.
func (m *DuplicateGroupMutation) ResetTotalSizeBytes() {
	m.total_size_bytes = nil
	m.addtotal_size_bytes = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DuplicateGroupMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[duplicategroup.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DuplicateGroupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DuplicateGroupMutation) TenantIDs() (ids []uuid.UUID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DuplicateGroupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearScan clears the "scan" edge to the Scan entity.
func (m *DuplicateGroupMutation) ClearScan() {
	m.clearedscan = true
	m.clearedFields[duplicategroup.FieldScanID] = struct{}{}
}

// ScanCleared reports if the "scan" edge to the Scan entity was cleared.
func (m *DuplicateGroupMutation) ScanCleared() bool {
	return m.clearedscan
}

// ScanIDs returns the "scan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScanID instead. It exists only for internal usage by the builders.
func (m *DuplicateGroupMutation) ScanIDs() (ids []uuid.UUID) {
	if id := m.scan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScan resets all changes to the "scan" edge.
func (m *DuplicateGroupMutation) ResetScan() {
	m.scan = nil
	m.clearedscan = false
}

// ClearKeeperMachine clears the "keeper_machine" edge to the Machine entity.
func (m *DuplicateGroupMutation) ClearKeeperMachine() {
	m.clearedkeeper_machine = true
	m.clearedFields[duplicategroup.FieldKeeperMachineID] = struct{}{}
}

// KeeperMachineCleared reports if the "keeper_machine" edge to the Machine entity was cleared.
func (m *DuplicateGroupMutation) KeeperMachineCleared() bool {
	return m.KeeperMachineIDCleared() || m.clearedkeeper_machine
}

// KeeperMachineIDs returns the "keeper_machine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// KeeperMachineID instead. It exists only for internal usage by the builders.
func (m *DuplicateGroupMutation) KeeperMachineIDs() (ids []uuid.UUID) {
	if id := m.keeper_machine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetKeeperMachine resets all changes to the "keeper_machine" edge.
func (m *DuplicateGroupMutation) ResetKeeperMachine() {
	m.keeper_machine = nil
	m.clearedkeeper_machine = false
}

// AddFileInstanceIDs adds the "file_instances" edge to the FileInstance entity by ids.
func (m *DuplicateGroupMutation) AddFileInstanceIDs(ids ...uuid.UUID) {
	if m.file_instances == nil {
		m.file_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.file_instances[ids[i]] = struct{}{}
	}
}

// ClearFileInstances clears the "file_instances" edge to the FileInstance entity.
func (m *DuplicateGroupMutation) ClearFileInstances() {
	m.clearedfile_instances = true
}

// FileInstancesCleared reports if the "file_instances" edge to the FileInstance entity was cleared.
func (m *DuplicateGroupMutation) FileInstancesCleared() bool {
	return m.clearedfile_instances
}

// RemoveFileInstanceIDs removes the "file_instances" edge to the FileInstance entity by IDs.
func (m *DuplicateGroupMutation) RemoveFileInstanceIDs(ids ...uuid.UUID) {
	if m.removedfile_instances == nil {
		m.removedfile_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.file_instances, ids[i])
		m.removedfile_instances[ids[i]] = struct{}{}
	}
}

// RemovedFileInstances returns the removed IDs of the "file_instances" edge to the FileInstance entity.
func (m *DuplicateGroupMutation) RemovedFileInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedfile_instances {
		ids = append(ids, id)
	}
	return
}

// FileInstancesIDs returns the "file_instances" edge IDs in the mutation.
func (m *DuplicateGroupMutation) FileInstancesIDs() (ids []uuid.UUID) {
	for id := range m.file_instances {
		ids = append(ids, id)
	}
	return
}

// ResetFileInstances resets all changes to the "file_instances" edge.
func (m *DuplicateGroupMutation) ResetFileInstances() {
	m.file_instances = nil
	m.clearedfile_instances = false
	m.removedfile_instances = nil
}

// AddActionAuditIDs adds the "action_audits" edge to the ActionAudit entity by ids.
func (m *DuplicateGroupMutation) AddActionAuditIDs(ids ...uuid.UUID) {
	if m.action_audits == nil {
		m.action_audits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.action_audits[ids[i]] = struct{}{}
	}
}

// ClearActionAudits clears the "action_audits" edge to the ActionAudit entity.
func (m *DuplicateGroupMutation) ClearActionAudits() {
	m.clearedaction_audits = true
}

// ActionAuditsCleared reports if the "action_audits" edge to the ActionAudit entity was cleared.
func (m *DuplicateGroupMutation) ActionAuditsCleared() bool {
	return m.clearedaction_audits
}

// RemoveActionAuditIDs removes the "action_audits" edge to the ActionAudit entity by IDs.
func (m *DuplicateGroupMutation) RemoveActionAuditIDs(ids ...uuid.UUID) {
	if m.removedaction_audits == nil {
		m.removedaction_audits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.action_audits, ids[i])
		m.removedaction_audits[ids[i]] = struct{}{}
	}
}

// RemovedActionAudits returns the removed IDs of the "action_audits" edge to the ActionAudit entity.
func (m *DuplicateGroupMutation) RemovedActionAuditsIDs() (ids []uuid.UUID) {
	for id := range m.removedaction_audits {
		ids = append(ids, id)
	}
	return
}

// ActionAuditsIDs returns the "action_audits" edge IDs in the mutation.
func (m *DuplicateGroupMutation) ActionAuditsIDs() (ids []uuid.UUID) {
	for id := range m.action_audits {
		ids = append(ids, id)
	}
	return
}

// ResetActionAudits resets all changes to the "action_audits" edge.
func (m *DuplicateGroupMutation) ResetActionAudits() {
	m.action_audits = nil
	m.clearedaction_audits = false
	m.removedaction_audits = nil
}

// Where appends a list predicates to the DuplicateGroupMutation builder.
func (m *DuplicateGroupMutation) Where(ps ...predicate.DuplicateGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DuplicateGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DuplicateGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DuplicateGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DuplicateGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DuplicateGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DuplicateGroup).
func (m *DuplicateGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DuplicateGroupMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, duplicategroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, duplicategroup.FieldUpdateTime)
	}
	if m.tenant != nil {
		fields = append(fields, duplicategroup.FieldTenantID)
	}
	if m.scan != nil {
		fields = append(fields, duplicategroup.FieldScanID)
	}
	if m.keeper_machine != nil {
		fields = append(fields, duplicategroup.FieldKeeperMachineID)
	}
	if m.hash != nil {
		fields = append(fields, duplicategroup.FieldHash)
	}
	if m.status != nil {
		fields = append(fields, duplicategroup.FieldStatus)
	}
	if m.file_count != nil {
		fields = append(fields, duplicategroup.FieldFileCount)
	}
	if m.total_size_bytes != nil {
		fields = append(fields, duplicategroup.FieldTotalSizeBytes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DuplicateGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case duplicategroup.FieldCreateTime:
		return m.CreateTime()
	case duplicategroup.FieldUpdateTime:
		return m.UpdateTime()
	case duplicategroup.FieldTenantID:
		return m.TenantID()
	case duplicategroup.FieldScanID:
		return m.ScanID()
	case duplicategroup.FieldKeeperMachineID:
		return m.KeeperMachineID()
	case duplicategroup.FieldHash:
		return m.Hash()
	case duplicategroup.FieldStatus:
		return m.Status()
	case duplicategroup.FieldFileCount:
		return m.FileCount()
	case duplicategroup.FieldTotalSizeBytes:
		return m.TotalSizeBytes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DuplicateGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case duplicategroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case duplicategroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case duplicategroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case duplicategroup.FieldScanID:
		return m.OldScanID(ctx)
	case duplicategroup.FieldKeeperMachineID:
		return m.OldKeeperMachineID(ctx)
	case duplicategroup.FieldHash:
		return m.OldHash(ctx)
	case duplicategroup.FieldStatus:
		return m.OldStatus(ctx)
	case duplicategroup.FieldFileCount:
		return m.OldFileCount(ctx)
	case duplicategroup.FieldTotalSizeBytes:
		return m.OldTotalSizeBytes(ctx)
	}
	return nil, fmt.Errorf("unknown DuplicateGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DuplicateGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case duplicategroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case duplicategroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case duplicategroup.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case duplicategroup.FieldScanID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanID(v)
		return nil
	case duplicategroup.FieldKeeperMachineID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeeperMachineID(v)
		return nil
	case duplicategroup.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case duplicategroup.FieldStatus:
		v, ok := value.(duplicategroup.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case duplicategroup.FieldFileCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileCount(v)
		return nil
	case duplicategroup.FieldTotalSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown DuplicateGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DuplicateGroupMutation) AddedFields() []string {
	var fields []string
	if m.addfile_count != nil {
		fields = append(fields, duplicategroup.FieldFileCount)
	}
	if m.addtotal_size_bytes != nil {
		fields = append(fields, duplicategroup.FieldTotalSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DuplicateGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case duplicategroup.FieldFileCount:
		return m.AddedFileCount()
	case duplicategroup.FieldTotalSizeBytes:
		return m.AddedTotalSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DuplicateGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case duplicategroup.FieldFileCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileCount(v)
		return nil
	case duplicategroup.FieldTotalSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown DuplicateGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DuplicateGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(duplicategroup.FieldKeeperMachineID) {
		fields = append(fields, duplicategroup.FieldKeeperMachineID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DuplicateGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DuplicateGroupMutation) ClearField(name string) error {
	switch name {
	case duplicategroup.FieldKeeperMachineID:
		m.ClearKeeperMachineID()
		return nil
	}
	return fmt.Errorf("unknown DuplicateGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DuplicateGroupMutation) ResetField(name string) error {
	switch name {
	case duplicategroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case duplicategroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case duplicategroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case duplicategroup.FieldScanID:
		m.ResetScanID()
		return nil
	case duplicategroup.FieldKeeperMachineID:
		m.ResetKeeperMachineID()
		return nil
	case duplicategroup.FieldHash:
		m.ResetHash()
		return nil
	case duplicategroup.FieldStatus:
		m.ResetStatus()
		return nil
	case duplicategroup.FieldFileCount:
		m.ResetFileCount()
		return nil
	case duplicategroup.FieldTotalSizeBytes:
		m.ResetTotalSizeBytes()
		return nil
	}
	return fmt.Errorf("unknown DuplicateGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DuplicateGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, duplicategroup.EdgeTenant)
	}
	if m.scan != nil {
		edges = append(edges, duplicategroup.EdgeScan)
	}
	if m.keeper_machine != nil {
		edges = append(edges, duplicategroup.EdgeKeeperMachine)
	}
	if m.file_instances != nil {
		edges = append(edges, duplicategroup.EdgeFileInstances)
	}
	if m.action_audits != nil {
		edges = append(edges, duplicategroup.EdgeActionAudits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DuplicateGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case duplicategroup.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case duplicategroup.EdgeScan:
		if id := m.scan; id != nil {
			return []ent.Value{*id}
		}
	case duplicategroup.EdgeKeeperMachine:
		if id := m.keeper_machine; id != nil {
			return []ent.Value{*id}
		}
	case duplicategroup.EdgeFileInstances:
		ids := make([]ent.Value, 0, len(m.file_instances))
		for id := range m.file_instances {
			ids = append(ids, id)
		}
		return ids
	case duplicategroup.EdgeActionAudits:
		ids := make([]ent.Value, 0, len(m.action_audits))
		for id := range m.action_audits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DuplicateGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedfile_instances != nil {
		edges = append(edges, duplicategroup.EdgeFileInstances)
	}
	if m.removedaction_audits != nil {
		edges = append(edges, duplicategroup.EdgeActionAudits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DuplicateGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case duplicategroup.EdgeFileInstances:
		ids := make([]ent.Value, 0, len(m.removedfile_instances))
		for id := range m.removedfile_instances {
			ids = append(ids, id)
		}
		return ids
	case duplicategroup.EdgeActionAudits:
		ids := make([]ent.Value, 0, len(m.removedaction_audits))
		for id := range m.removedaction_audits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DuplicateGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, duplicategroup.EdgeTenant)
	}
	if m.clearedscan {
		edges = append(edges, duplicategroup.EdgeScan)
	}
	if m.clearedkeeper_machine {
		edges = append(edges, duplicategroup.EdgeKeeperMachine)
	}
	if m.clearedfile_instances {
		edges = append(edges, duplicategroup.EdgeFileInstances)
	}
	if m.clearedaction_audits {
		edges = append(edges, duplicategroup.EdgeActionAudits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DuplicateGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case duplicategroup.EdgeTenant:
		return m.clearedtenant
	case duplicategroup.EdgeScan:
		return m.clearedscan
	case duplicategroup.EdgeKeeperMachine:
		return m.clearedkeeper_machine
	case duplicategroup.EdgeFileInstances:
		return m.clearedfile_instances
	case duplicategroup.EdgeActionAudits:
		return m.clearedaction_audits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DuplicateGroupMutation) ClearEdge(name string) error {
	switch name {
	case duplicategroup.EdgeTenant:
		m.ClearTenant()
		return nil
	case duplicategroup.EdgeScan:
		m.ClearScan()
		return nil
	case duplicategroup.EdgeKeeperMachine:
		m.ClearKeeperMachine()
		return nil
	}
	return fmt.Errorf("unknown DuplicateGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DuplicateGroupMutation) ResetEdge(name string) error {
	switch name {
	case duplicategroup.EdgeTenant:
		m.ResetTenant()
		return nil
	case duplicategroup.EdgeScan:
		m.ResetScan()
		return nil
	case duplicategroup.EdgeKeeperMachine:
		m.ResetKeeperMachine()
		return nil
	case duplicategroup.EdgeFileInstances:
		m.ResetFileInstances()
		return nil
	case duplicategroup.EdgeActionAudits:
		m.ResetActionAudits()
		return nil
	}
	return fmt.Errorf("unknown DuplicateGroup edge %s", name)
}

// FileInstanceMutation represents an operation that mutates the FileInstance nodes in the graph.
type FileInstanceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	_path                  *string
	size_bytes             *int64
	addsize_bytes          *int64
	checksum               *string
	last_seen_at           *time.Time
	quarantined            *bool
	clearedFields          map[string]struct{}
	duplicate_group        *uuid.UUID
	clearedduplicate_group bool
	machine                *uuid.UUID
	clearedmachine         bool
	done                   bool
	oldValue               func(context.Context) (*FileInstance, error)
	predicates             []predicate.FileInstance
}

var _ ent.Mutation = (*FileInstanceMutation)(nil)

// fileinstanceOption allows management of the mutation configuration using functional options.
type fileinstanceOption func(*FileInstanceMutation)

// newFileInstanceMutation creates new mutation for the FileInstance entity.
func newFileInstanceMutation(c config, op Op, opts ...fileinstanceOption) *FileInstanceMutation {
	m := &FileInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeFileInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileInstanceID sets the ID field of the mutation.
func withFileInstanceID(id uuid.UUID) fileinstanceOption {
	return func(m *FileInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *FileInstance
		)
		m.oldValue = func(ctx context.Context) (*FileInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileInstance sets the old FileInstance of the mutation.
func withFileInstance(node *FileInstance) fileinstanceOption {
	return func(m *FileInstanceMutation) {
		m.oldValue = func(context.Context) (*FileInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileInstance entities.
func (m *FileInstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileInstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileInstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FileInstanceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FileInstanceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FileInstanceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FileInstanceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FileInstanceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FileInstanceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDuplicateGroupID sets the "duplicate_group_id" field.
func (m *FileInstanceMutation) SetDuplicateGroupID(u uuid.UUID) {
	m.duplicate_group = &u
}

// DuplicateGroupID returns the value of the "duplicate_group_id" field in the mutation.
func (m *FileInstanceMutation) DuplicateGroupID() (r uuid.UUID, exists bool) {
	v := m.duplicate_group
	if v == nil {
		return
	}
	return *v, true
}

// OldDuplicateGroupID returns the old "duplicate_group_id" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldDuplicateGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuplicateGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuplicateGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuplicateGroupID: %w", err)
	}
	return oldValue.DuplicateGroupID, nil
}

// ResetDuplicateGroupID resets all changes to the "duplicate_group_id" field.
func (m *FileInstanceMutation) ResetDuplicateGroupID() {
	m.duplicate_group = nil
}

// SetMachineID sets the "machine_id" field.
func (m *FileInstanceMutation) SetMachineID(u uuid.UUID) {
	m.machine = &u
}

// MachineID returns the value of the "machine_id" field in the mutation.
func (m *FileInstanceMutation) MachineID() (r uuid.UUID, exists bool) {
	v := m.machine
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineID returns the old "machine_id" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldMachineID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMachineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMachineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineID: %w", err)
	}
	return oldValue.MachineID, nil
}

// ResetMachineID resets all changes to the "machine_id" field.
func (m *FileInstanceMutation) ResetMachineID() {
	m.machine = nil
}

// SetPath sets the "path" field.
func (m *FileInstanceMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileInstanceMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileInstanceMutation) ResetPath() {
	m._path = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *FileInstanceMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *FileInstanceMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *FileInstanceMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *FileInstanceMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *FileInstanceMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
}

// SetChecksum sets the "checksum" field.
func (m *FileInstanceMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *FileInstanceMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *FileInstanceMutation) ResetChecksum() {
	m.checksum = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *FileInstanceMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *FileInstanceMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldLastSeenAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *FileInstanceMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
}

// SetQuarantined sets the "quarantined" field.
func (m *FileInstanceMutation) SetQuarantined(b bool) {
	m.quarantined = &b
}

// Quarantined returns the value of the "quarantined" field in the mutation.
func (m *FileInstanceMutation) Quarantined() (r bool, exists bool) {
	v := m.quarantined
	if v == nil {
		return
	}
	return *v, true
}

// OldQuarantined returns the old "quarantined" field's value of the FileInstance entity.
// If the FileInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileInstanceMutation) OldQuarantined(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuarantined is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuarantined requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuarantined: %w", err)
	}
	return oldValue.Quarantined, nil
}

// ResetQuarantined resets all changes to the "quarantined" field.
func (m *FileInstanceMutation) ResetQuarantined() {
	m.quarantined = nil
}

// ClearDuplicateGroup clears the "duplicate_group" edge to the DuplicateGroup entity.
func (m *FileInstanceMutation) ClearDuplicateGroup() {
	m.clearedduplicate_group = true
	m.clearedFields[fileinstance.FieldDuplicateGroupID] = struct{}{}
}

// DuplicateGroupCleared reports if the "duplicate_group" edge to the DuplicateGroup entity was cleared.
func (m *FileInstanceMutation) DuplicateGroupCleared() bool {
	return m.clearedduplicate_group
}

// DuplicateGroupIDs returns the "duplicate_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DuplicateGroupID instead. It exists only for internal usage by the builders.
func (m *FileInstanceMutation) DuplicateGroupIDs() (ids []uuid.UUID) {
	if id := m.duplicate_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDuplicateGroup resets all changes to the "duplicate_group" edge.
func (m *FileInstanceMutation) ResetDuplicateGroup() {
	m.duplicate_group = nil
	m.clearedduplicate_group = false
}

// ClearMachine clears the "machine" edge to the Machine entity.
func (m *FileInstanceMutation) ClearMachine() {
	m.clearedmachine = true
	m.clearedFields[fileinstance.FieldMachineID] = struct{}{}
}

// MachineCleared reports if the "machine" edge to the Machine entity was cleared.
func (m *FileInstanceMutation) MachineCleared() bool {
	return m.clearedmachine
}

// MachineIDs returns the "machine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MachineID instead. It exists only for internal usage by the builders.
func (m *FileInstanceMutation) MachineIDs() (ids []uuid.UUID) {
	if id := m.machine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMachine resets all changes to the "machine" edge.
func (m *FileInstanceMutation) ResetMachine() {
	m.machine = nil
	m.clearedmachine = false
}

// Where appends a list predicates to the FileInstanceMutation builder.
func (m *FileInstanceMutation) Where(ps ...predicate.FileInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileInstance).
func (m *FileInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileInstanceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, fileinstance.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, fileinstance.FieldUpdateTime)
	}
	if m.duplicate_group != nil {
		fields = append(fields, fileinstance.FieldDuplicateGroupID)
	}
	if m.machine != nil {
		fields = append(fields, fileinstance.FieldMachineID)
	}
	if m._path != nil {
		fields = append(fields, fileinstance.FieldPath)
	}
	if m.size_bytes != nil {
		fields = append(fields, fileinstance.FieldSizeBytes)
	}
	if m.checksum != nil {
		fields = append(fields, fileinstance.FieldChecksum)
	}
	if m.last_seen_at != nil {
		fields = append(fields, fileinstance.FieldLastSeenAt)
	}
	if m.quarantined != nil {
		fields = append(fields, fileinstance.FieldQuarantined)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileinstance.FieldCreateTime:
		return m.CreateTime()
	case fileinstance.FieldUpdateTime:
		return m.UpdateTime()
	case fileinstance.FieldDuplicateGroupID:
		return m.DuplicateGroupID()
	case fileinstance.FieldMachineID:
		return m.MachineID()
	case fileinstance.FieldPath:
		return m.Path()
	case fileinstance.FieldSizeBytes:
		return m.SizeBytes()
	case fileinstance.FieldChecksum:
		return m.Checksum()
	case fileinstance.FieldLastSeenAt:
		return m.LastSeenAt()
	case fileinstance.FieldQuarantined:
		return m.Quarantined()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileinstance.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case fileinstance.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case fileinstance.FieldDuplicateGroupID:
		return m.OldDuplicateGroupID(ctx)
	case fileinstance.FieldMachineID:
		return m.OldMachineID(ctx)
	case fileinstance.FieldPath:
		return m.OldPath(ctx)
	case fileinstance.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case fileinstance.FieldChecksum:
		return m.OldChecksum(ctx)
	case fileinstance.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	case fileinstance.FieldQuarantined:
		return m.OldQuarantined(ctx)
	}
	return nil, fmt.Errorf("unknown FileInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileinstance.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case fileinstance.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case fileinstance.FieldDuplicateGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuplicateGroupID(v)
		return nil
	case fileinstance.FieldMachineID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineID(v)
		return nil
	case fileinstance.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case fileinstance.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case fileinstance.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case fileinstance.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	case fileinstance.FieldQuarantined:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuarantined(v)
		return nil
	}
	return fmt.Errorf("unknown FileInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, fileinstance.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fileinstance.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fileinstance.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown FileInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileInstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileInstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileInstanceMutation) ResetField(name string) error {
	switch name {
	case fileinstance.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case fileinstance.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case fileinstance.FieldDuplicateGroupID:
		m.ResetDuplicateGroupID()
		return nil
	case fileinstance.FieldMachineID:
		m.ResetMachineID()
		return nil
	case fileinstance.FieldPath:
		m.ResetPath()
		return nil
	case fileinstance.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case fileinstance.FieldChecksum:
		m.ResetChecksum()
		return nil
	case fileinstance.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	case fileinstance.FieldQuarantined:
		m.ResetQuarantined()
		return nil
	}
	return fmt.Errorf("unknown FileInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.duplicate_group != nil {
		edges = append(edges, fileinstance.EdgeDuplicateGroup)
	}
	if m.machine != nil {
		edges = append(edges, fileinstance.EdgeMachine)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fileinstance.EdgeDuplicateGroup:
		if id := m.duplicate_group; id != nil {
			return []ent.Value{*id}
		}
	case fileinstance.EdgeMachine:
		if id := m.machine; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedduplicate_group {
		edges = append(edges, fileinstance.EdgeDuplicateGroup)
	}
	if m.clearedmachine {
		edges = append(edges, fileinstance.EdgeMachine)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case fileinstance.EdgeDuplicateGroup:
		return m.clearedduplicate_group
	case fileinstance.EdgeMachine:
		return m.clearedmachine
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileInstanceMutation) ClearEdge(name string) error {
	switch name {
	case fileinstance.EdgeDuplicateGroup:
		m.ClearDuplicateGroup()
		return nil
	case fileinstance.EdgeMachine:
		m.ClearMachine()
		return nil
	}
	return fmt.Errorf("unknown FileInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileInstanceMutation) ResetEdge(name string) error {
	switch name {
	case fileinstance.EdgeDuplicateGroup:
		m.ResetDuplicateGroup()
		return nil
	case fileinstance.EdgeMachine:
		m.ResetMachine()
		return nil
	}
	return fmt.Errorf("unknown FileInstance edge %s", name)
}

// MachineMutation represents an operation that mutates the Machine nodes in the graph.
type MachineMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	name                   *string
	category               *machine.Category
	hostname               *string
	role                   *string
	last_scan_at           *time.Time
	clearedFields          map[string]struct{}
	tenant                 *uuid.UUID
	clearedtenant          bool
	keeper_groups          map[uuid.UUID]struct{}
	removedkeeper_groups   map[uuid.UUID]struct{}
	clearedkeeper_groups   bool
	file_instances         map[uuid.UUID]struct{}
	removedfile_instances  map[uuid.UUID]struct{}
	clearedfile_instances  bool
	initiated_scans        map[uuid.UUID]struct{}
	removedinitiated_scans map[uuid.UUID]struct{}
	clearedinitiated_scans bool
	done                   bool
	oldValue               func(context.Context) (*Machine, error)
	predicates             []predicate.Machine
}

var _ ent.Mutation = (*MachineMutation)(nil)

// machineOption allows management of the mutation configuration using functional options.
type machineOption func(*MachineMutation)

// newMachineMutation creates new mutation for the Machine entity.
func newMachineMutation(c config, op Op, opts ...machineOption) *MachineMutation {
	m := &MachineMutation{
		config:        c,
		op:            op,
		typ:           TypeMachine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMachineID sets the ID field of the mutation.
func withMachineID(id uuid.UUID) machineOption {
	return func(m *MachineMutation) {
		var (
			err   error
			once  sync.Once
			value *Machine
		)
		m.oldValue = func(ctx context.Context) (*Machine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Machine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMachine sets the old Machine of the mutation.
func withMachine(node *Machine) machineOption {
	return func(m *MachineMutation) {
		m.oldValue = func(context.Context) (*Machine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MachineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MachineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Machine entities.
func (m *MachineMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MachineMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MachineMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Machine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MachineMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MachineMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MachineMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MachineMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MachineMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MachineMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *MachineMutation) SetTenantID(u uuid.UUID) {
	m.tenant = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *MachineMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *MachineMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *MachineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MachineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MachineMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *MachineMutation) SetCategory(value machine.Category) {
	m.category = &value
}

// Category returns the value of the "category" field in the mutation.
func (m *MachineMutation) Category() (r machine.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldCategory(ctx context.Context) (v machine.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MachineMutation) ResetCategory() {
	m.category = nil
}

// SetHostname sets the "hostname" field.
func (m *MachineMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *MachineMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ClearHostname clears the value of the "hostname" field.
func (m *MachineMutation) ClearHostname() {
	m.hostname = nil
	m.clearedFields[machine.FieldHostname] = struct{}{}
}

// HostnameCleared returns if the "hostname" field was cleared in this mutation.
func (m *MachineMutation) HostnameCleared() bool {
	_, ok := m.clearedFields[machine.FieldHostname]
	return ok
}

// ResetHostname resets all changes to the "hostname" field.
func (m *MachineMutation) ResetHostname() {
	m.hostname = nil
	delete(m.clearedFields, machine.FieldHostname)
}

// SetRole sets the "role" field.
func (m *MachineMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *MachineMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *MachineMutation) ClearRole() {
	m.role = nil
	m.clearedFields[machine.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *MachineMutation) RoleCleared() bool {
	_, ok := m.clearedFields[machine.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *MachineMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, machine.FieldRole)
}

// SetLastScanAt sets the "last_scan_at" field.
func (m *MachineMutation) SetLastScanAt(t time.Time) {
	m.last_scan_at = &t
}

// LastScanAt returns the value of the "last_scan_at" field in the mutation.
func (m *MachineMutation) LastScanAt() (r time.Time, exists bool) {
	v := m.last_scan_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastScanAt returns the old "last_scan_at" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldLastScanAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastScanAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastScanAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastScanAt: %w", err)
	}
	return oldValue.LastScanAt, nil
}

// ClearLastScanAt clears the value of the "last_scan_at" field.
func (m *MachineMutation) ClearLastScanAt() {
	m.last_scan_at = nil
	m.clearedFields[machine.FieldLastScanAt] = struct{}{}
}

// LastScanAtCleared returns if the "last_scan_at" field was cleared in this mutation.
func (m *MachineMutation) LastScanAtCleared() bool {
	_, ok := m.clearedFields[machine.FieldLastScanAt]
	return ok
}

// ResetLastScanAt resets all changes to the "last_scan_at" field.
func (m *MachineMutation) ResetLastScanAt() {
	m.last_scan_at = nil
	delete(m.clearedFields, machine.FieldLastScanAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *MachineMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[machine.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *MachineMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *MachineMutation) TenantIDs() (ids []uuid.UUID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *MachineMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddKeeperGroupIDs adds the "keeper_groups" edge to the DuplicateGroup entity by ids.
func (m *MachineMutation) AddKeeperGroupIDs(ids ...uuid.UUID) {
	if m.keeper_groups == nil {
		m.keeper_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.keeper_groups[ids[i]] = struct{}{}
	}
}

// ClearKeeperGroups clears the "keeper_groups" edge to the DuplicateGroup entity.
func (m *MachineMutation) ClearKeeperGroups() {
	m.clearedkeeper_groups = true
}

// KeeperGroupsCleared reports if the "keeper_groups" edge to the DuplicateGroup entity was cleared.
func (m *MachineMutation) KeeperGroupsCleared() bool {
	return m.clearedkeeper_groups
}

// RemoveKeeperGroupIDs removes the "keeper_groups" edge to the DuplicateGroup entity by IDs.
func (m *MachineMutation) RemoveKeeperGroupIDs(ids ...uuid.UUID) {
	if m.removedkeeper_groups == nil {
		m.removedkeeper_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.keeper_groups, ids[i])
		m.removedkeeper_groups[ids[i]] = struct{}{}
	}
}

// RemovedKeeperGroups returns the removed IDs of the "keeper_groups" edge to the DuplicateGroup entity.
func (m *MachineMutation) RemovedKeeperGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedkeeper_groups {
		ids = append(ids, id)
	}
	return
}

// KeeperGroupsIDs returns the "keeper_groups" edge IDs in the mutation.
func (m *MachineMutation) KeeperGroupsIDs() (ids []uuid.UUID) {
	for id := range m.keeper_groups {
		ids = append(ids, id)
	}
	return
}

// ResetKeeperGroups resets all changes to the "keeper_groups" edge.
func (m *MachineMutation) ResetKeeperGroups() {
	m.keeper_groups = nil
	m.clearedkeeper_groups = false
	m.removedkeeper_groups = nil
}

// AddFileInstanceIDs adds the "file_instances" edge to the FileInstance entity by ids.
func (m *MachineMutation) AddFileInstanceIDs(ids ...uuid.UUID) {
	if m.file_instances == nil {
		m.file_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.file_instances[ids[i]] = struct{}{}
	}
}

// ClearFileInstances clears the "file_instances" edge to the FileInstance entity.
func (m *MachineMutation) ClearFileInstances() {
	m.clearedfile_instances = true
}

// FileInstancesCleared reports if the "file_instances" edge to the FileInstance entity was cleared.
func (m *MachineMutation) FileInstancesCleared() bool {
	return m.clearedfile_instances
}

// RemoveFileInstanceIDs removes the "file_instances" edge to the FileInstance entity by IDs.
func (m *MachineMutation) RemoveFileInstanceIDs(ids ...uuid.UUID) {
	if m.removedfile_instances == nil {
		m.removedfile_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.file_instances, ids[i])
		m.removedfile_instances[ids[i]] = struct{}{}
	}
}

// RemovedFileInstances returns the removed IDs of the "file_instances" edge to the FileInstance entity.
func (m *MachineMutation) RemovedFileInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedfile_instances {
		ids = append(ids, id)
	}
	return
}

// FileInstancesIDs returns the "file_instances" edge IDs in the mutation.
func (m *MachineMutation) FileInstancesIDs() (ids []uuid.UUID) {
	for id := range m.file_instances {
		ids = append(ids, id)
	}
	return
}

// ResetFileInstances resets all changes to the "file_instances" edge.
func (m *MachineMutation) ResetFileInstances() {
	m.file_instances = nil
	m.clearedfile_instances = false
	m.removedfile_instances = nil
}

// AddInitiatedScanIDs adds the "initiated_scans" edge to the Scan entity by ids.
func (m *MachineMutation) AddInitiatedScanIDs(ids ...uuid.UUID) {
	if m.initiated_scans == nil {
		m.initiated_scans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.initiated_scans[ids[i]] = struct{}{}
	}
}

// ClearInitiatedScans clears the "initiated_scans" edge to the Scan entity.
func (m *MachineMutation) ClearInitiatedScans() {
	m.clearedinitiated_scans = true
}

// InitiatedScansCleared reports if the "initiated_scans" edge to the Scan entity was cleared.
func (m *MachineMutation) InitiatedScansCleared() bool {
	return m.clearedinitiated_scans
}

// RemoveInitiatedScanIDs removes the "initiated_scans" edge to the Scan entity by IDs.
func (m *MachineMutation) RemoveInitiatedScanIDs(ids ...uuid.UUID) {
	if m.removedinitiated_scans == nil {
		m.removedinitiated_scans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.initiated_scans, ids[i])
		m.removedinitiated_scans[ids[i]] = struct{}{}
	}
}

// RemovedInitiatedScans returns the removed IDs of the "initiated_scans" edge to the Scan entity.
func (m *MachineMutation) RemovedInitiatedScansIDs() (ids []uuid.UUID) {
	for id := range m.removedinitiated_scans {
		ids = append(ids, id)
	}
	return
}

// InitiatedScansIDs returns the "initiated_scans" edge IDs in the mutation.
func (m *MachineMutation) InitiatedScansIDs() (ids []uuid.UUID) {
	for id := range m.initiated_scans {
		ids = append(ids, id)
	}
	return
}

// ResetInitiatedScans resets all changes to the "initiated_scans" edge.
func (m *MachineMutation) ResetInitiatedScans() {
	m.initiated_scans = nil
	m.clearedinitiated_scans = false
	m.removedinitiated_scans = nil
}

// Where appends a list predicates to the MachineMutation builder.
func (m *MachineMutation) Where(ps ...predicate.Machine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MachineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MachineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Machine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MachineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MachineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Machine).
func (m *MachineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MachineMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, machine.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, machine.FieldUpdateTime)
	}
	if m.tenant != nil {
		fields = append(fields, machine.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, machine.FieldName)
	}
	if m.category != nil {
		fields = append(fields, machine.FieldCategory)
	}
	if m.hostname != nil {
		fields = append(fields, machine.FieldHostname)
	}
	if m.role != nil {
		fields = append(fields, machine.FieldRole)
	}
	if m.last_scan_at != nil {
		fields = append(fields, machine.FieldLastScanAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MachineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case machine.FieldCreateTime:
		return m.CreateTime()
	case machine.FieldUpdateTime:
		return m.UpdateTime()
	case machine.FieldTenantID:
		return m.TenantID()
	case machine.FieldName:
		return m.Name()
	case machine.FieldCategory:
		return m.Category()
	case machine.FieldHostname:
		return m.Hostname()
	case machine.FieldRole:
		return m.Role()
	case machine.FieldLastScanAt:
		return m.LastScanAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MachineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case machine.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case machine.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case machine.FieldTenantID:
		return m.OldTenantID(ctx)
	case machine.FieldName:
		return m.OldName(ctx)
	case machine.FieldCategory:
		return m.OldCategory(ctx)
	case machine.FieldHostname:
		return m.OldHostname(ctx)
	case machine.FieldRole:
		return m.OldRole(ctx)
	case machine.FieldLastScanAt:
		return m.OldLastScanAt(ctx)
	}
	return nil, fmt.Errorf("unknown Machine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case machine.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case machine.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case machine.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case machine.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case machine.FieldCategory:
		v, ok := value.(machine.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case machine.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case machine.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case machine.FieldLastScanAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastScanAt(v)
		return nil
	}
	return fmt.Errorf("unknown Machine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MachineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MachineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Machine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MachineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(machine.FieldHostname) {
		fields = append(fields, machine.FieldHostname)
	}
	if m.FieldCleared(machine.FieldRole) {
		fields = append(fields, machine.FieldRole)
	}
	if m.FieldCleared(machine.FieldLastScanAt) {
		fields = append(fields, machine.FieldLastScanAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MachineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MachineMutation) ClearField(name string) error {
	switch name {
	case machine.FieldHostname:
		m.ClearHostname()
		return nil
	case machine.FieldRole:
		m.ClearRole()
		return nil
	case machine.FieldLastScanAt:
		m.ClearLastScanAt()
		return nil
	}
	return fmt.Errorf("unknown Machine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MachineMutation) ResetField(name string) error {
	switch name {
	case machine.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case machine.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case machine.FieldTenantID:
		m.ResetTenantID()
		return nil
	case machine.FieldName:
		m.ResetName()
		return nil
	case machine.FieldCategory:
		m.ResetCategory()
		return nil
	case machine.FieldHostname:
		m.ResetHostname()
		return nil
	case machine.FieldRole:
		m.ResetRole()
		return nil
	case machine.FieldLastScanAt:
		m.ResetLastScanAt()
		return nil
	}
	return fmt.Errorf("unknown Machine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MachineMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, machine.EdgeTenant)
	}
	if m.keeper_groups != nil {
		edges = append(edges, machine.EdgeKeeperGroups)
	}
	if m.file_instances != nil {
		edges = append(edges, machine.EdgeFileInstances)
	}
	if m.initiated_scans != nil {
		edges = append(edges, machine.EdgeInitiatedScans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MachineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case machine.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case machine.EdgeKeeperGroups:
		ids := make([]ent.Value, 0, len(m.keeper_groups))
		for id := range m.keeper_groups {
			ids = append(ids, id)
		}
		return ids
	case machine.EdgeFileInstances:
		ids := make([]ent.Value, 0, len(m.file_instances))
		for id := range m.file_instances {
			ids = append(ids, id)
		}
		return ids
	case machine.EdgeInitiatedScans:
		ids := make([]ent.Value, 0, len(m.initiated_scans))
		for id := range m.initiated_scans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MachineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedkeeper_groups != nil {
		edges = append(edges, machine.EdgeKeeperGroups)
	}
	if m.removedfile_instances != nil {
		edges = append(edges, machine.EdgeFileInstances)
	}
	if m.removedinitiated_scans != nil {
		edges = append(edges, machine.EdgeInitiatedScans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MachineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case machine.EdgeKeeperGroups:
		ids := make([]ent.Value, 0, len(m.removedkeeper_groups))
		for id := range m.removedkeeper_groups {
			ids = append(ids, id)
		}
		return ids
	case machine.EdgeFileInstances:
		ids := make([]ent.Value, 0, len(m.removedfile_instances))
		for id := range m.removedfile_instances {
			ids = append(ids, id)
		}
		return ids
	case machine.EdgeInitiatedScans:
		ids := make([]ent.Value, 0, len(m.removedinitiated_scans))
		for id := range m.removedinitiated_scans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MachineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, machine.EdgeTenant)
	}
	if m.clearedkeeper_groups {
		edges = append(edges, machine.EdgeKeeperGroups)
	}
	if m.clearedfile_instances {
		edges = append(edges, machine.EdgeFileInstances)
	}
	if m.clearedinitiated_scans {
		edges = append(edges, machine.EdgeInitiatedScans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MachineMutation) EdgeCleared(name string) bool {
	switch name {
	case machine.EdgeTenant:
		return m.clearedtenant
	case machine.EdgeKeeperGroups:
		return m.clearedkeeper_groups
	case machine.EdgeFileInstances:
		return m.clearedfile_instances
	case machine.EdgeInitiatedScans:
		return m.clearedinitiated_scans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MachineMutation) ClearEdge(name string) error {
	switch name {
	case machine.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Machine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MachineMutation) ResetEdge(name string) error {
	switch name {
	case machine.EdgeTenant:
		m.ResetTenant()
		return nil
	case machine.EdgeKeeperGroups:
		m.ResetKeeperGroups()
		return nil
	case machine.EdgeFileInstances:
		m.ResetFileInstances()
		return nil
	case machine.EdgeInitiatedScans:
		m.ResetInitiatedScans()
		return nil
	}
	return fmt.Errorf("unknown Machine edge %s", name)
}

// ScanMutation represents an operation that mutates the Scan nodes in the graph.
type ScanMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	name                     *string
	description              *string
	started_at               *time.Time
	completed_at             *time.Time
	duplicate_group_count    *int
	addduplicate_group_count *int
	clearedFields            map[string]struct{}
	tenant                   *uuid.UUID
	clearedtenant            bool
	initiated_machine        *uuid.UUID
	clearedinitiated_machine bool
	duplicate_groups         map[uuid.UUID]struct{}
	removedduplicate_groups  map[uuid.UUID]struct{}
	clearedduplicate_groups  bool
	done                     bool
	oldValue                 func(context.Context) (*Scan, error)
	predicates               []predicate.Scan
}

var _ ent.Mutation = (*ScanMutation)(nil)

// scanOption allows management of the mutation configuration using functional options.
type scanOption func(*ScanMutation)

// newScanMutation creates new mutation for the Scan entity.
func newScanMutation(c config, op Op, opts ...scanOption) *ScanMutation {
	m := &ScanMutation{
		config:        c,
		op:            op,
		typ:           TypeScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScanID sets the ID field of the mutation.
func withScanID(id uuid.UUID) scanOption {
	return func(m *ScanMutation) {
		var (
			err   error
			once  sync.Once
			value *Scan
		)
		m.oldValue = func(ctx context.Context) (*Scan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScan sets the old Scan of the mutation.
func withScan(node *Scan) scanOption {
	return func(m *ScanMutation) {
		m.oldValue = func(context.Context) (*Scan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Scan entities.
func (m *ScanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ScanMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ScanMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ScanMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ScanMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ScanMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ScanMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ScanMutation) SetTenantID(u uuid.UUID) {
	m.tenant = &u
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ScanMutation) TenantID() (r uuid.UUID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldTenantID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ScanMutation) ResetTenantID() {
	m.tenant = nil
}

// SetInitiatedMachineID sets the "initiated_machine_id" field.
func (m *ScanMutation) SetInitiatedMachineID(u uuid.UUID) {
	m.initiated_machine = &u
}

// InitiatedMachineID returns the value of the "initiated_machine_id" field in the mutation.
func (m *ScanMutation) InitiatedMachineID() (r uuid.UUID, exists bool) {
	v := m.initiated_machine
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiatedMachineID returns the old "initiated_machine_id" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldInitiatedMachineID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiatedMachineID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiatedMachineID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiatedMachineID: %w", err)
	}
	return oldValue.InitiatedMachineID, nil
}

// ClearInitiatedMachineID clears the value of the "initiated_machine_id" field.
func (m *ScanMutation) ClearInitiatedMachineID() {
	m.initiated_machine = nil
	m.clearedFields[scan.FieldInitiatedMachineID] = struct{}{}
}

// InitiatedMachineIDCleared returns if the "initiated_machine_id" field was cleared in this mutation.
func (m *ScanMutation) InitiatedMachineIDCleared() bool {
	_, ok := m.clearedFields[scan.FieldInitiatedMachineID]
	return ok
}

// ResetInitiatedMachineID resets all changes to the "initiated_machine_id" field.
func (m *ScanMutation) ResetInitiatedMachineID() {
	m.initiated_machine = nil
	delete(m.clearedFields, scan.FieldInitiatedMachineID)
}

// SetName sets the "name" field.
func (m *ScanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ScanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ScanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[scan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ScanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[scan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ScanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, scan.FieldDescription)
}

// SetStartedAt sets the "started_at" field.
func (m *ScanMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ScanMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ScanMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *ScanMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *ScanMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *ScanMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[scan.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *ScanMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[scan.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *ScanMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, scan.FieldCompletedAt)
}

// SetDuplicateGroupCount sets the "duplicate_group_count" field.
func (m *ScanMutation) SetDuplicateGroupCount(i int) {
	m.duplicate_group_count = &i
	m.addduplicate_group_count = nil
}

// DuplicateGroupCount returns the value of the "duplicate_group_count" field in the mutation.
func (m *ScanMutation) DuplicateGroupCount() (r int, exists bool) {
	v := m.duplicate_group_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDuplicateGroupCount returns the old "duplicate_group_count" field's value of the Scan entity.
// If the Scan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScanMutation) OldDuplicateGroupCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuplicateGroupCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuplicateGroupCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuplicateGroupCount: %w", err)
	}
	return oldValue.DuplicateGroupCount, nil
}

// AddDuplicateGroupCount adds i to the "duplicate_group_count" field.
func (m *ScanMutation) AddDuplicateGroupCount(i int) {
	if m.addduplicate_group_count != nil {
		*m.addduplicate_group_count += i
	} else {
		m.addduplicate_group_count = &i
	}
}

// AddedDuplicateGroupCount returns the value that was added to the "duplicate_group_count" field in this mutation.
func (m *ScanMutation) AddedDuplicateGroupCount() (r int, exists bool) {
	v := m.addduplicate_group_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuplicateGroupCount resets all changes to the "duplicate_group_count" field.
func (m *ScanMutation) ResetDuplicateGroupCount() {
	m.duplicate_group_count = nil
	m.addduplicate_group_count = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ScanMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[scan.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ScanMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ScanMutation) TenantIDs() (ids []uuid.UUID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ScanMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearInitiatedMachine clears the "initiated_machine" edge to the Machine entity.
func (m *ScanMutation) ClearInitiatedMachine() {
	m.clearedinitiated_machine = true
	m.clearedFields[scan.FieldInitiatedMachineID] = struct{}{}
}

// InitiatedMachineCleared reports if the "initiated_machine" edge to the Machine entity was cleared.
func (m *ScanMutation) InitiatedMachineCleared() bool {
	return m.InitiatedMachineIDCleared() || m.clearedinitiated_machine
}

// InitiatedMachineIDs returns the "initiated_machine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InitiatedMachineID instead. It exists only for internal usage by the builders.
func (m *ScanMutation) InitiatedMachineIDs() (ids []uuid.UUID) {
	if id := m.initiated_machine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInitiatedMachine resets all changes to the "initiated_machine" edge.
func (m *ScanMutation) ResetInitiatedMachine() {
	m.initiated_machine = nil
	m.clearedinitiated_machine = false
}

// AddDuplicateGroupIDs adds the "duplicate_groups" edge to the DuplicateGroup entity by ids.
func (m *ScanMutation) AddDuplicateGroupIDs(ids ...uuid.UUID) {
	if m.duplicate_groups == nil {
		m.duplicate_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.duplicate_groups[ids[i]] = struct{}{}
	}
}

// ClearDuplicateGroups clears the "duplicate_groups" edge to the DuplicateGroup entity.
func (m *ScanMutation) ClearDuplicateGroups() {
	m.clearedduplicate_groups = true
}

// DuplicateGroupsCleared reports if the "duplicate_groups" edge to the DuplicateGroup entity was cleared.
func (m *ScanMutation) DuplicateGroupsCleared() bool {
	return m.clearedduplicate_groups
}

// RemoveDuplicateGroupIDs removes the "duplicate_groups" edge to the DuplicateGroup entity by IDs.
func (m *ScanMutation) RemoveDuplicateGroupIDs(ids ...uuid.UUID) {
	if m.removedduplicate_groups == nil {
		m.removedduplicate_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.duplicate_groups, ids[i])
		m.removedduplicate_groups[ids[i]] = struct{}{}
	}
}

// RemovedDuplicateGroups returns the removed IDs of the "duplicate_groups" edge to the DuplicateGroup entity.
func (m *ScanMutation) RemovedDuplicateGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedduplicate_groups {
		ids = append(ids, id)
	}
	return
}

// DuplicateGroupsIDs returns the "duplicate_groups" edge IDs in the mutation.
func (m *ScanMutation) DuplicateGroupsIDs() (ids []uuid.UUID) {
	for id := range m.duplicate_groups {
		ids = append(ids, id)
	}
	return
}

// ResetDuplicateGroups resets all changes to the "duplicate_groups" edge.
func (m *ScanMutation) ResetDuplicateGroups() {
	m.duplicate_groups = nil
	m.clearedduplicate_groups = false
	m.removedduplicate_groups = nil
}

// Where appends a list predicates to the ScanMutation builder.
func (m *ScanMutation) Where(ps ...predicate.Scan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scan).
func (m *ScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScanMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, scan.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, scan.FieldUpdateTime)
	}
	if m.tenant != nil {
		fields = append(fields, scan.FieldTenantID)
	}
	if m.initiated_machine != nil {
		fields = append(fields, scan.FieldInitiatedMachineID)
	}
	if m.name != nil {
		fields = append(fields, scan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, scan.FieldDescription)
	}
	if m.started_at != nil {
		fields = append(fields, scan.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, scan.FieldCompletedAt)
	}
	if m.duplicate_group_count != nil {
		fields = append(fields, scan.FieldDuplicateGroupCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldCreateTime:
		return m.CreateTime()
	case scan.FieldUpdateTime:
		return m.UpdateTime()
	case scan.FieldTenantID:
		return m.TenantID()
	case scan.FieldInitiatedMachineID:
		return m.InitiatedMachineID()
	case scan.FieldName:
		return m.Name()
	case scan.FieldDescription:
		return m.Description()
	case scan.FieldStartedAt:
		return m.StartedAt()
	case scan.FieldCompletedAt:
		return m.CompletedAt()
	case scan.FieldDuplicateGroupCount:
		return m.DuplicateGroupCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scan.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case scan.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case scan.FieldTenantID:
		return m.OldTenantID(ctx)
	case scan.FieldInitiatedMachineID:
		return m.OldInitiatedMachineID(ctx)
	case scan.FieldName:
		return m.OldName(ctx)
	case scan.FieldDescription:
		return m.OldDescription(ctx)
	case scan.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case scan.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case scan.FieldDuplicateGroupCount:
		return m.OldDuplicateGroupCount(ctx)
	}
	return nil, fmt.Errorf("unknown Scan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scan.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case scan.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case scan.FieldTenantID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case scan.FieldInitiatedMachineID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiatedMachineID(v)
		return nil
	case scan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case scan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case scan.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case scan.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case scan.FieldDuplicateGroupCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuplicateGroupCount(v)
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScanMutation) AddedFields() []string {
	var fields []string
	if m.addduplicate_group_count != nil {
		fields = append(fields, scan.FieldDuplicateGroupCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scan.FieldDuplicateGroupCount:
		return m.AddedDuplicateGroupCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scan.FieldDuplicateGroupCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuplicateGroupCount(v)
		return nil
	}
	return fmt.Errorf("unknown Scan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scan.FieldInitiatedMachineID) {
		fields = append(fields, scan.FieldInitiatedMachineID)
	}
	if m.FieldCleared(scan.FieldDescription) {
		fields = append(fields, scan.FieldDescription)
	}
	if m.FieldCleared(scan.FieldCompletedAt) {
		fields = append(fields, scan.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScanMutation) ClearField(name string) error {
	switch name {
	case scan.FieldInitiatedMachineID:
		m.ClearInitiatedMachineID()
		return nil
	case scan.FieldDescription:
		m.ClearDescription()
		return nil
	case scan.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown Scan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScanMutation) ResetField(name string) error {
	switch name {
	case scan.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case scan.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case scan.FieldTenantID:
		m.ResetTenantID()
		return nil
	case scan.FieldInitiatedMachineID:
		m.ResetInitiatedMachineID()
		return nil
	case scan.FieldName:
		m.ResetName()
		return nil
	case scan.FieldDescription:
		m.ResetDescription()
		return nil
	case scan.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case scan.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case scan.FieldDuplicateGroupCount:
		m.ResetDuplicateGroupCount()
		return nil
	}
	return fmt.Errorf("unknown Scan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, scan.EdgeTenant)
	}
	if m.initiated_machine != nil {
		edges = append(edges, scan.EdgeInitiatedMachine)
	}
	if m.duplicate_groups != nil {
		edges = append(edges, scan.EdgeDuplicateGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case scan.EdgeInitiatedMachine:
		if id := m.initiated_machine; id != nil {
			return []ent.Value{*id}
		}
	case scan.EdgeDuplicateGroups:
		ids := make([]ent.Value, 0, len(m.duplicate_groups))
		for id := range m.duplicate_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedduplicate_groups != nil {
		edges = append(edges, scan.EdgeDuplicateGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case scan.EdgeDuplicateGroups:
		ids := make([]ent.Value, 0, len(m.removedduplicate_groups))
		for id := range m.removedduplicate_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, scan.EdgeTenant)
	}
	if m.clearedinitiated_machine {
		edges = append(edges, scan.EdgeInitiatedMachine)
	}
	if m.clearedduplicate_groups {
		edges = append(edges, scan.EdgeDuplicateGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScanMutation) EdgeCleared(name string) bool {
	switch name {
	case scan.EdgeTenant:
		return m.clearedtenant
	case scan.EdgeInitiatedMachine:
		return m.clearedinitiated_machine
	case scan.EdgeDuplicateGroups:
		return m.clearedduplicate_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScanMutation) ClearEdge(name string) error {
	switch name {
	case scan.EdgeTenant:
		m.ClearTenant()
		return nil
	case scan.EdgeInitiatedMachine:
		m.ClearInitiatedMachine()
		return nil
	}
	return fmt.Errorf("unknown Scan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScanMutation) ResetEdge(name string) error {
	switch name {
	case scan.EdgeTenant:
		m.ResetTenant()
		return nil
	case scan.EdgeInitiatedMachine:
		m.ResetInitiatedMachine()
		return nil
	case scan.EdgeDuplicateGroups:
		m.ResetDuplicateGroups()
		return nil
	}
	return fmt.Errorf("unknown Scan edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	slug                    *string
	name                    *string
	description             *string
	primary_contact         *string
	clearedFields           map[string]struct{}
	machines                map[uuid.UUID]struct{}
	removedmachines         map[uuid.UUID]struct{}
	clearedmachines         bool
	scans                   map[uuid.UUID]struct{}
	removedscans            map[uuid.UUID]struct{}
	clearedscans            bool
	duplicate_groups        map[uuid.UUID]struct{}
	removedduplicate_groups map[uuid.UUID]struct{}
	clearedduplicate_groups bool
	action_audits           map[uuid.UUID]struct{}
	removedaction_audits    map[uuid.UUID]struct{}
	clearedaction_audits    bool
	done                    bool
	oldValue                func(context.Context) (*Tenant, error)
	predicates              []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id uuid.UUID) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TenantMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TenantMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TenantMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TenantMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TenantMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TenantMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSlug sets the "slug" field.
func (m *TenantMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TenantMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TenantMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TenantMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TenantMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TenantMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tenant.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TenantMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TenantMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tenant.FieldDescription)
}

// SetPrimaryContact sets the "primary_contact" field.
func (m *TenantMutation) SetPrimaryContact(s string) {
	m.primary_contact = &s
}

// PrimaryContact returns the value of the "primary_contact" field in the mutation.
func (m *TenantMutation) PrimaryContact() (r string, exists bool) {
	v := m.primary_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryContact returns the old "primary_contact" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPrimaryContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryContact: %w", err)
	}
	return oldValue.PrimaryContact, nil
}

// ClearPrimaryContact clears the value of the "primary_contact" field.
func (m *TenantMutation) ClearPrimaryContact() {
	m.primary_contact = nil
	m.clearedFields[tenant.FieldPrimaryContact] = struct{}{}
}

// PrimaryContactCleared returns if the "primary_contact" field was cleared in this mutation.
func (m *TenantMutation) PrimaryContactCleared() bool {
	_, ok := m.clearedFields[tenant.FieldPrimaryContact]
	return ok
}

// ResetPrimaryContact resets all changes to the "primary_contact" field.
func (m *TenantMutation) ResetPrimaryContact() {
	m.primary_contact = nil
	delete(m.clearedFields, tenant.FieldPrimaryContact)
}

// AddMachineIDs adds the "machines" edge to the Machine entity by ids.
func (m *TenantMutation) AddMachineIDs(ids ...uuid.UUID) {
	if m.machines == nil {
		m.machines = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.machines[ids[i]] = struct{}{}
	}
}

// ClearMachines clears the "machines" edge to the Machine entity.
func (m *TenantMutation) ClearMachines() {
	m.clearedmachines = true
}

// MachinesCleared reports if the "machines" edge to the Machine entity was cleared.
func (m *TenantMutation) MachinesCleared() bool {
	return m.clearedmachines
}

// RemoveMachineIDs removes the "machines" edge to the Machine entity by IDs.
func (m *TenantMutation) RemoveMachineIDs(ids ...uuid.UUID) {
	if m.removedmachines == nil {
		m.removedmachines = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.machines, ids[i])
		m.removedmachines[ids[i]] = struct{}{}
	}
}

// RemovedMachines returns the removed IDs of the "machines" edge to the Machine entity.
func (m *TenantMutation) RemovedMachinesIDs() (ids []uuid.UUID) {
	for id := range m.removedmachines {
		ids = append(ids, id)
	}
	return
}

// MachinesIDs returns the "machines" edge IDs in the mutation.
func (m *TenantMutation) MachinesIDs() (ids []uuid.UUID) {
	for id := range m.machines {
		ids = append(ids, id)
	}
	return
}

// ResetMachines resets all changes to the "machines" edge.
func (m *TenantMutation) ResetMachines() {
	m.machines = nil
	m.clearedmachines = false
	m.removedmachines = nil
}

// AddScanIDs adds the "scans" edge to the Scan entity by ids.
func (m *TenantMutation) AddScanIDs(ids ...uuid.UUID) {
	if m.scans == nil {
		m.scans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.scans[ids[i]] = struct{}{}
	}
}

// ClearScans clears the "scans" edge to the Scan entity.
func (m *TenantMutation) ClearScans() {
	m.clearedscans = true
}

// ScansCleared reports if the "scans" edge to the Scan entity was cleared.
func (m *TenantMutation) ScansCleared() bool {
	return m.clearedscans
}

// RemoveScanIDs removes the "scans" edge to the Scan entity by IDs.
func (m *TenantMutation) RemoveScanIDs(ids ...uuid.UUID) {
	if m.removedscans == nil {
		m.removedscans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.scans, ids[i])
		m.removedscans[ids[i]] = struct{}{}
	}
}

// RemovedScans returns the removed IDs of the "scans" edge to the Scan entity.
func (m *TenantMutation) RemovedScansIDs() (ids []uuid.UUID) {
	for id := range m.removedscans {
		ids = append(ids, id)
	}
	return
}

// ScansIDs returns the "scans" edge IDs in the mutation.
func (m *TenantMutation) ScansIDs() (ids []uuid.UUID) {
	for id := range m.scans {
		ids = append(ids, id)
	}
	return
}

// ResetScans resets all changes to the "scans" edge.
func (m *TenantMutation) ResetScans() {
	m.scans = nil
	m.clearedscans = false
	m.removedscans = nil
}

// AddDuplicateGroupIDs adds the "duplicate_groups" edge to the DuplicateGroup entity by ids.
func (m *TenantMutation) AddDuplicateGroupIDs(ids ...uuid.UUID) {
	if m.duplicate_groups == nil {
		m.duplicate_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.duplicate_groups[ids[i]] = struct{}{}
	}
}

// ClearDuplicateGroups clears the "duplicate_groups" edge to the DuplicateGroup entity.
func (m *TenantMutation) ClearDuplicateGroups() {
	m.clearedduplicate_groups = true
}

// DuplicateGroupsCleared reports if the "duplicate_groups" edge to the DuplicateGroup entity was cleared.
func (m *TenantMutation) DuplicateGroupsCleared() bool {
	return m.clearedduplicate_groups
}

// RemoveDuplicateGroupIDs removes the "duplicate_groups" edge to the DuplicateGroup entity by IDs.
func (m *TenantMutation) RemoveDuplicateGroupIDs(ids ...uuid.UUID) {
	if m.removedduplicate_groups == nil {
		m.removedduplicate_groups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.duplicate_groups, ids[i])
		m.removedduplicate_groups[ids[i]] = struct{}{}
	}
}

// RemovedDuplicateGroups returns the removed IDs of the "duplicate_groups" edge to the DuplicateGroup entity.
func (m *TenantMutation) RemovedDuplicateGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removedduplicate_groups {
		ids = append(ids, id)
	}
	return
}

// DuplicateGroupsIDs returns the "duplicate_groups" edge IDs in the mutation.
func (m *TenantMutation) DuplicateGroupsIDs() (ids []uuid.UUID) {
	for id := range m.duplicate_groups {
		ids = append(ids, id)
	}
	return
}

// ResetDuplicateGroups resets all changes to the "duplicate_groups" edge.
func (m *TenantMutation) ResetDuplicateGroups() {
	m.duplicate_groups = nil
	m.clearedduplicate_groups = false
	m.removedduplicate_groups = nil
}

// AddActionAuditIDs adds the "action_audits" edge to the ActionAudit entity by ids.
func (m *TenantMutation) AddActionAuditIDs(ids ...uuid.UUID) {
	if m.action_audits == nil {
		m.action_audits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.action_audits[ids[i]] = struct{}{}
	}
}

// ClearActionAudits clears the "action_audits" edge to the ActionAudit entity.
func (m *TenantMutation) ClearActionAudits() {
	m.clearedaction_audits = true
}

// ActionAuditsCleared reports if the "action_audits" edge to the ActionAudit entity was cleared.
func (m *TenantMutation) ActionAuditsCleared() bool {
	return m.clearedaction_audits
}

// RemoveActionAuditIDs removes the "action_audits" edge to the ActionAudit entity by IDs.
func (m *TenantMutation) RemoveActionAuditIDs(ids ...uuid.UUID) {
	if m.removedaction_audits == nil {
		m.removedaction_audits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.action_audits, ids[i])
		m.removedaction_audits[ids[i]] = struct{}{}
	}
}

// RemovedActionAudits returns the removed IDs of the "action_audits" edge to the ActionAudit entity.
func (m *TenantMutation) RemovedActionAuditsIDs() (ids []uuid.UUID) {
	for id := range m.removedaction_audits {
		ids = append(ids, id)
	}
	return
}

// ActionAuditsIDs returns the "action_audits" edge IDs in the mutation.
func (m *TenantMutation) ActionAuditsIDs() (ids []uuid.UUID) {
	for id := range m.action_audits {
		ids = append(ids, id)
	}
	return
}

// ResetActionAudits resets all changes to the "action_audits" edge.
func (m *TenantMutation) ResetActionAudits() {
	m.action_audits = nil
	m.clearedaction_audits = false
	m.removedaction_audits = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, tenant.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tenant.FieldUpdateTime)
	}
	if m.slug != nil {
		fields = append(fields, tenant.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tenant.FieldDescription)
	}
	if m.primary_contact != nil {
		fields = append(fields, tenant.FieldPrimaryContact)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCreateTime:
		return m.CreateTime()
	case tenant.FieldUpdateTime:
		return m.UpdateTime()
	case tenant.FieldSlug:
		return m.Slug()
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldDescription:
		return m.Description()
	case tenant.FieldPrimaryContact:
		return m.PrimaryContact()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tenant.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tenant.FieldSlug:
		return m.OldSlug(ctx)
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldDescription:
		return m.OldDescription(ctx)
	case tenant.FieldPrimaryContact:
		return m.OldPrimaryContact(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tenant.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tenant.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tenant.FieldPrimaryContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryContact(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldDescription) {
		fields = append(fields, tenant.FieldDescription)
	}
	if m.FieldCleared(tenant.FieldPrimaryContact) {
		fields = append(fields, tenant.FieldPrimaryContact)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldDescription:
		m.ClearDescription()
		return nil
	case tenant.FieldPrimaryContact:
		m.ClearPrimaryContact()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tenant.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tenant.FieldSlug:
		m.ResetSlug()
		return nil
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldDescription:
		m.ResetDescription()
		return nil
	case tenant.FieldPrimaryContact:
		m.ResetPrimaryContact()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.machines != nil {
		edges = append(edges, tenant.EdgeMachines)
	}
	if m.scans != nil {
		edges = append(edges, tenant.EdgeScans)
	}
	if m.duplicate_groups != nil {
		edges = append(edges, tenant.EdgeDuplicateGroups)
	}
	if m.action_audits != nil {
		edges = append(edges, tenant.EdgeActionAudits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeMachines:
		ids := make([]ent.Value, 0, len(m.machines))
		for id := range m.machines {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeScans:
		ids := make([]ent.Value, 0, len(m.scans))
		for id := range m.scans {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDuplicateGroups:
		ids := make([]ent.Value, 0, len(m.duplicate_groups))
		for id := range m.duplicate_groups {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeActionAudits:
		ids := make([]ent.Value, 0, len(m.action_audits))
		for id := range m.action_audits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmachines != nil {
		edges = append(edges, tenant.EdgeMachines)
	}
	if m.removedscans != nil {
		edges = append(edges, tenant.EdgeScans)
	}
	if m.removedduplicate_groups != nil {
		edges = append(edges, tenant.EdgeDuplicateGroups)
	}
	if m.removedaction_audits != nil {
		edges = append(edges, tenant.EdgeActionAudits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeMachines:
		ids := make([]ent.Value, 0, len(m.removedmachines))
		for id := range m.removedmachines {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeScans:
		ids := make([]ent.Value, 0, len(m.removedscans))
		for id := range m.removedscans {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeDuplicateGroups:
		ids := make([]ent.Value, 0, len(m.removedduplicate_groups))
		for id := range m.removedduplicate_groups {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeActionAudits:
		ids := make([]ent.Value, 0, len(m.removedaction_audits))
		for id := range m.removedaction_audits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmachines {
		edges = append(edges, tenant.EdgeMachines)
	}
	if m.clearedscans {
		edges = append(edges, tenant.EdgeScans)
	}
	if m.clearedduplicate_groups {
		edges = append(edges, tenant.EdgeDuplicateGroups)
	}
	if m.clearedaction_audits {
		edges = append(edges, tenant.EdgeActionAudits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeMachines:
		return m.clearedmachines
	case tenant.EdgeScans:
		return m.clearedscans
	case tenant.EdgeDuplicateGroups:
		return m.clearedduplicate_groups
	case tenant.EdgeActionAudits:
		return m.clearedaction_audits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeMachines:
		m.ResetMachines()
		return nil
	case tenant.EdgeScans:
		m.ResetScans()
		return nil
	case tenant.EdgeDuplicateGroups:
		m.ResetDuplicateGroups()
		return nil
	case tenant.EdgeActionAudits:
		m.ResetActionAudits()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}
